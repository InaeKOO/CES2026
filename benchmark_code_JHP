import os
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from tqdm.auto import tqdm
import warnings
import random
import copy

warnings.filterwarnings('ignore')
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# =========================================================
# âš™ï¸ ì„¤ì •: 100ë²ˆ ë°˜ë³µ ì‹¤í—˜
# =========================================================
NUM_RUNS = 100Â  # 100ë²ˆ ë°˜ë³µ

class Config:
Â  Â  STOCKS = ['META', 'TSLA', 'NFLX', 'NVDA', 'PLTR', 'MSFT', 'GOOG', 'AAPL', 'AVGO', 'AMZN']
Â  Â  START_DATE = '2020-11-02'
Â  Â  TRAIN_END = '2023-12-31'
Â  Â  TEST_START = '2024-01-01'
Â  Â  END_DATE = '2025-10-31'
Â  Â  INITIAL_CAPITAL = 10000.0

# =========================================================
# ğŸ› ï¸ ìœ í‹¸ë¦¬í‹°: ì‹œë“œ ê³ ì • & ë°ì´í„° ë¡œë“œ
# =========================================================
def set_all_seeds(seed):
Â  Â  random.seed(seed)
Â  Â  np.random.seed(seed)
Â  Â  torch.manual_seed(seed)
Â  Â  if torch.cuda.is_available():
Â  Â  Â  Â  torch.cuda.manual_seed(seed)
Â  Â  Â  Â  torch.cuda.manual_seed_all(seed)
Â  Â  Â  Â  torch.backends.cudnn.deterministic = True
Â  Â  Â  Â  torch.backends.cudnn.benchmark = False

def load_local_files():
Â  Â  print("ğŸ“‚ [Smart Loader] /content í´ë”ì—ì„œ íŒŒì¼ íƒìƒ‰ ì¤‘...")
Â  Â Â 
Â  Â  search_dir = '/content'
Â  Â  if not os.path.exists(search_dir):Â 
Â  Â  Â  Â  search_dir = '.'Â 
Â  Â  Â  Â Â 
Â  Â  all_files = [f for f in os.listdir(search_dir) if f.endswith('.csv')]
Â  Â Â 
Â  Â  close_dict = {}
Â  Â  volume_dict = {}
Â  Â  loaded_count = 0
Â  Â Â 
Â  Â  for s in Config.STOCKS:
Â  Â  Â  Â  target_file = None
Â  Â  Â  Â  for fname in all_files:
Â  Â  Â  Â  Â  Â  if s.upper() in fname.upper():
Â  Â  Â  Â  Â  Â  Â  Â  target_file = os.path.join(search_dir, fname)
Â  Â  Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â Â 
Â  Â  Â  Â  if not target_file:
Â  Â  Â  Â  Â  Â  print(f"Â  âš ï¸ [{s}] íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ëª©ë¡ì— ì—†ìŒ)")
Â  Â  Â  Â  Â  Â  continue

Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  df = pd.read_csv(target_file)
Â  Â  Â  Â  Â  Â  df.columns = df.columns.str.strip()
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if 'Date' in df.columns: df['Date'] = pd.to_datetime(df['Date'])
Â  Â  Â  Â  Â  Â  else: df.rename(columns={df.columns[0]: 'Date'}, inplace=True); df['Date'] = pd.to_datetime(df['Date'])
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  col_close = next((c for c in df.columns if 'close' in c.lower() or 'last' in c.lower()), None)
Â  Â  Â  Â  Â  Â  if col_close:
Â  Â  Â  Â  Â  Â  Â  Â  val_close = df[col_close].astype(str).str.replace(r'[$,]', '', regex=True).astype(float) if df[col_close].dtype == object else df[col_close]
Â  Â  Â  Â  Â  Â  else: continue

Â  Â  Â  Â  Â  Â  col_vol = next((c for c in df.columns if 'vol' in c.lower()), None)
Â  Â  Â  Â  Â  Â  if col_vol:
Â  Â  Â  Â  Â  Â  Â  Â  val_vol = df[col_vol].astype(str).str.replace(r'[$,]', '', regex=True).astype(float) if df[col_vol].dtype == object else df[col_vol]
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  val_vol = pd.Series(0, index=df.index)

Â  Â  Â  Â  Â  Â  df = df.set_index('Date').sort_index()
Â  Â  Â  Â  Â  Â  df = df[~df.index.duplicated(keep='last')]
Â  Â  Â  Â  Â  Â  mask = (df.index >= Config.START_DATE) & (df.index <= Config.END_DATE)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  close_dict[s] = val_close.loc[mask]
Â  Â  Â  Â  Â  Â  volume_dict[s] = val_vol.loc[mask]
Â  Â  Â  Â  Â  Â  loaded_count += 1
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  except Exception as e:
Â  Â  Â  Â  Â  Â  print(f"Â  âŒ {s} ë¡œë“œ ì‹¤íŒ¨: {e}")

Â  Â  if not close_dict:Â 
Â  Â  Â  Â  print("âŒ ë¡œë“œëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
Â  Â  Â  Â  return None, None
Â  Â Â 
Â  Â  print(f"âœ… ì´ {loaded_count}ê°œ ì¢…ëª© ë¡œë“œ ì™„ë£Œ!")
Â  Â  close_df = pd.DataFrame(close_dict).fillna(method='ffill').fillna(method='bfill')
Â  Â  volume_df = pd.DataFrame(volume_dict).fillna(0)
Â  Â Â 
Â  Â  return close_df, volume_df

# =========================================================
# ğŸ§  ëª¨ë¸ ì½”ì–´ ì •ì˜
# =========================================================
class iTransformerCore(nn.Module):
Â  Â  def __init__(self, num_vars, seq_len=60, d_model=64):
Â  Â  Â  Â  super().__init__()
Â  Â  Â  Â  self.enc_embedding = nn.Linear(seq_len, d_model)
Â  Â  Â  Â  self.encoder = nn.TransformerEncoder(
Â  Â  Â  Â  Â  Â  nn.TransformerEncoderLayer(d_model, nhead=4, batch_first=True, dropout=0.1), num_layers=2
Â  Â  Â  Â  )
Â  Â  Â  Â  self.proj = nn.Linear(d_model, 1)

Â  Â  def forward(self, x):
Â  Â  Â  Â  x = x.permute(0, 2, 1)
Â  Â  Â  Â  x = self.enc_embedding(x)
Â  Â  Â  Â  x = self.encoder(x)
Â  Â  Â  Â  return self.proj(x).squeeze(-1)

class PatchTSTCore(nn.Module):
Â  Â  def __init__(self, seq_len=60):
Â  Â  Â  Â  super().__init__()
Â  Â  Â  Â  self.linear = nn.Linear(seq_len, 1)
Â  Â  def forward(self, x):
Â  Â  Â  Â  x = x.permute(0, 2, 1)
Â  Â  Â  Â  return self.linear(x).squeeze(-1)

class QuantformerCore(nn.Module):
Â  Â  def __init__(self, input_dim=2, d_model=32, nhead=4, num_layers=2):
Â  Â  Â  Â  super().__init__()
Â  Â  Â  Â  self.embedding = nn.Linear(input_dim, d_model)
Â  Â  Â  Â  self.encoder = nn.TransformerEncoder(
Â  Â  Â  Â  Â  Â  nn.TransformerEncoderLayer(d_model=d_model, nhead=nhead, batch_first=True, dropout=0.1),
Â  Â  Â  Â  Â  Â  num_layers=num_layers
Â  Â  Â  Â  )
Â  Â  Â  Â  self.fc_out = nn.Linear(d_model, 3)Â 
Â  Â  Â  Â  self.softmax = nn.Softmax(dim=-1)

Â  Â  def forward(self, x):
Â  Â  Â  Â  x = self.embedding(x)
Â  Â  Â  Â  x = self.encoder(x)
Â  Â  Â  Â  return self.softmax(self.fc_out(x[:, -1, :]))

# =========================================================
# ğŸ¤– 5ê°œ ì—ì´ì „íŠ¸ (ë²„ê·¸ ìˆ˜ì • ì™„ë£Œ)
# =========================================================

# [Team 1] JJH - [ìˆ˜ì •ë¨: ì…ë ¥ ìŠ¤ì¼€ì¼ ë¶ˆì¼ì¹˜ í•´ê²°]
class Agent_JJH:
Â  Â  def __init__(self, num_stocks):
Â  Â  Â  Â  self.model = iTransformerCore(num_stocks).to(device)
Â  Â  Â  Â  self.optimizer = optim.Adam(self.model.parameters(), lr=0.001)
Â  Â Â 
Â  Â  def train(self, close_df, vol_df):
Â  Â  Â  Â  data = close_df.pct_change().fillna(0).values
Â  Â  Â  Â  X, y = [], []
Â  Â  Â  Â  for i in range(len(data) - 60):
Â  Â  Â  Â  Â  Â  X.append(data[i:i+60])
Â  Â  Â  Â  Â  Â  y.append(data[i+60])
Â  Â  Â  Â  X_t = torch.FloatTensor(np.array(X)).to(device)
Â  Â  Â  Â  y_t = torch.FloatTensor(np.array(y)).to(device)
Â  Â  Â  Â Â 
Â  Â  Â  Â  self.model.train()
Â  Â  Â  Â  for _ in range(5):
Â  Â  Â  Â  Â  Â  self.optimizer.zero_grad()
Â  Â  Â  Â  Â  Â  loss = nn.MSELoss()(self.model(X_t), y_t)
Â  Â  Â  Â  Â  Â  loss.backward()
Â  Â  Â  Â  Â  Â  self.optimizer.step()
Â  Â  Â  Â  Â  Â Â 
Â  Â  def trade(self, close_win, vol_win):
Â  Â  Â  Â  self.model.eval()
Â  Â  Â  Â  # [FIX] ì£¼ê°€(Raw Price)ê°€ ì•„ë‹Œ ìˆ˜ìµë¥ (Return)ì„ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•´ì•¼ í•¨!
Â  Â  Â  Â  inp_data = close_win.pct_change().fillna(0).values
Â  Â  Â  Â  inp = torch.FloatTensor(inp_data).unsqueeze(0).to(device)
Â  Â  Â  Â Â 
Â  Â  Â  Â  with torch.no_grad(): scores = self.model(inp).cpu().numpy()[0]
Â  Â  Â  Â  w = np.zeros(len(scores))
Â  Â  Â  Â  w[np.argsort(scores)[-3:]] = 1/3
Â  Â  Â  Â  return w

# [Team 2] JHP (Quantformer Edition)
class Agent_JHP:
Â  Â  def __init__(self, num_stocks):
Â  Â  Â  Â  self.model = QuantformerCore(input_dim=2).to(device)
Â  Â  Â  Â  self.optimizer = optim.Adam(self.model.parameters(), lr=0.001)
Â  Â  Â  Â  self.lookback = 20
Â  Â  Â  Â  self.stocks = Config.STOCKS
Â  Â  Â  Â Â 
Â  Â  def _prepare_data(self, close_df, vol_df):
Â  Â  Â  Â  X_list, y_list = [], []
Â  Â  Â  Â  ret_df = close_df.pct_change().fillna(0)
Â  Â  Â  Â  turn_df = vol_df.pct_change().fillna(0)
Â  Â  Â  Â Â 
Â  Â  Â  Â  for stock in self.stocks:
Â  Â  Â  Â  Â  Â  rets = ret_df[stock].values
Â  Â  Â  Â  Â  Â  turns = turn_df[stock].values
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  for i in range(len(rets) - self.lookback):
Â  Â  Â  Â  Â  Â  Â  Â  seq_ret = rets[i : i+self.lookback]
Â  Â  Â  Â  Â  Â  Â  Â  seq_turn = turns[i : i+self.lookback]
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  seq = np.stack([seq_ret, seq_turn], axis=1)Â 
Â  Â  Â  Â  Â  Â  Â  Â  mean = seq.mean(axis=0)
Â  Â  Â  Â  Â  Â  Â  Â  std = seq.std(axis=0) + 1e-8
Â  Â  Â  Â  Â  Â  Â  Â  seq_norm = (seq - mean) / std
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  next_r = rets[i+self.lookback]
Â  Â  Â  Â  Â  Â  Â  Â  if next_r > 0.005: label = 0Â 
Â  Â  Â  Â  Â  Â  Â  Â  elif next_r < -0.005: label = 2Â 
Â  Â  Â  Â  Â  Â  Â  Â  else: label = 1Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  X_list.append(seq_norm)
Â  Â  Â  Â  Â  Â  Â  Â  y_list.append(label)
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  return torch.FloatTensor(np.array(X_list)).to(device), torch.LongTensor(np.array(y_list)).to(device)

Â  Â  def train(self, close_df, vol_df):
Â  Â  Â  Â  X, y = self._prepare_data(close_df, vol_df)
Â  Â  Â  Â  self.model.train()
Â  Â  Â  Â  criterion = nn.CrossEntropyLoss()
Â  Â  Â  Â Â 
Â  Â  Â  Â  if len(X) > 5000:
Â  Â  Â  Â  Â  Â  idx = torch.randperm(len(X))[:5000]
Â  Â  Â  Â  Â  Â  X_sub, y_sub = X[idx], y[idx]
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  X_sub, y_sub = X, y
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  for _ in range(5):
Â  Â  Â  Â  Â  Â  self.optimizer.zero_grad()
Â  Â  Â  Â  Â  Â  pred = self.model(X_sub)
Â  Â  Â  Â  Â  Â  loss = criterion(pred, y_sub)
Â  Â  Â  Â  Â  Â  loss.backward()
Â  Â  Â  Â  Â  Â  self.optimizer.step()

Â  Â  def trade(self, close_win, vol_win):
Â  Â  Â  Â  self.model.eval()
Â  Â  Â  Â Â 
Â  Â  Â  Â  ret_win = close_win.pct_change().fillna(0).iloc[-20:]
Â  Â  Â  Â  vol_win_pct = vol_win.pct_change().fillna(0).iloc[-20:]
Â  Â  Â  Â Â 
Â  Â  Â  Â  probs = []
Â  Â  Â  Â  for i in range(len(self.stocks)):
Â  Â  Â  Â  Â  Â  seq = np.stack([ret_win.iloc[:, i].values, vol_win_pct.iloc[:, i].values], axis=1)
Â  Â  Â  Â  Â  Â  mean = seq.mean(axis=0)
Â  Â  Â  Â  Â  Â  std = seq.std(axis=0) + 1e-8
Â  Â  Â  Â  Â  Â  seq_norm = (seq - mean) / std
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  inp = torch.FloatTensor(seq_norm).unsqueeze(0).to(device)
Â  Â  Â  Â  Â  Â  with torch.no_grad():
Â  Â  Â  Â  Â  Â  Â  Â  out = self.model(inp)
Â  Â  Â  Â  Â  Â  Â  Â  bull_prob = out[0][0].item()
Â  Â  Â  Â  Â  Â  Â  Â  probs.append(bull_prob)
Â  Â  Â  Â Â 
Â  Â  Â  Â  w = np.zeros(len(self.stocks))
Â  Â  Â  Â  w[np.argsort(probs)[-3:]] = 1/3
Â  Â  Â  Â  return w

# [Team 3] IHK
class Agent_IHK:
Â  Â  def __init__(self, n): pass
Â  Â  def train(self, c, v): pass
Â  Â  def trade(self, close_win, vol_win):
Â  Â  Â  Â  vol = close_win.pct_change().std().values + 1e-6
Â  Â  Â  Â  inv_vol = 1.0 / vol
Â  Â  Â  Â  return inv_vol / np.sum(inv_vol)

# [Team 4] HJK
class Agent_HJK:
Â  Â  def __init__(self, n):
Â  Â  Â  Â  self.model = PatchTSTCore().to(device)
Â  Â  Â  Â  self.opt = optim.Adam(self.model.parameters(), lr=0.001)
Â  Â  def train(self, close_df, vol_df):
Â  Â  Â  Â  data = close_df.pct_change().fillna(0).values
Â  Â  Â  Â  X, y = [], []
Â  Â  Â  Â  for i in range(len(data) - 60):
Â  Â  Â  Â  Â  Â  X.append(data[i:i+60])
Â  Â  Â  Â  Â  Â  y.append(data[i+60])
Â  Â  Â  Â  X_t = torch.FloatTensor(np.array(X)).to(device)
Â  Â  Â  Â  y_t = torch.FloatTensor(np.array(y)).to(device)
Â  Â  Â  Â Â 
Â  Â  Â  Â  self.model.train()
Â  Â  Â  Â  for _ in range(5):
Â  Â  Â  Â  Â  Â  self.opt.zero_grad()
Â  Â  Â  Â  Â  Â  loss = nn.MSELoss()(self.model(X_t), y_t)
Â  Â  Â  Â  Â  Â  loss.backward()
Â  Â  Â  Â  Â  Â  self.opt.step()
Â  Â  def trade(self, c_win, v_win):
Â  Â  Â  Â  self.model.eval()
Â  Â  Â  Â  inp = c_win.pct_change().fillna(0).values
Â  Â  Â  Â  inp = torch.FloatTensor(inp).unsqueeze(0).to(device)
Â  Â  Â  Â  with torch.no_grad(): s = self.model(inp).cpu().numpy()[0]
Â  Â  Â  Â  w = np.zeros(len(s))
Â  Â  Â  Â  w[np.argsort(s)[-3:]] = 1/3
Â  Â  Â  Â  return w

# [Team 5] YRK
class Agent_YRK:
Â  Â  def __init__(self, n):
Â  Â  Â  Â  self.m = iTransformerCore(n).to(device)
Â  Â  Â  Â  self.h = nn.Linear(n, n).to(device)
Â  Â  Â  Â  self.opt = optim.Adam(list(self.m.parameters())+list(self.h.parameters()), lr=0.001)
Â  Â  def train(self, close_df, vol_df):
Â  Â  Â  Â  data = close_df.pct_change().fillna(0).values
Â  Â  Â  Â  X, y = [], []
Â  Â  Â  Â  for i in range(len(data) - 60):
Â  Â  Â  Â  Â  Â  X.append(data[i:i+60])
Â  Â  Â  Â  Â  Â  y.append(data[i+60])
Â  Â  Â  Â  X_t = torch.FloatTensor(np.array(X)).to(device)
Â  Â  Â  Â  y_t = torch.FloatTensor(np.array(y)).to(device)
Â  Â  Â  Â Â 
Â  Â  Â  Â  self.m.train()
Â  Â  Â  Â  for _ in range(5):
Â  Â  Â  Â  Â  Â  self.opt.zero_grad()
Â  Â  Â  Â  Â  Â  loss = nn.MSELoss()(self.h(self.m(X_t)), y_t)
Â  Â  Â  Â  Â  Â  loss.backward()
Â  Â  Â  Â  Â  Â  self.opt.step()
Â  Â  def trade(self, c_win, v_win):
Â  Â  Â  Â  self.m.eval()
Â  Â  Â  Â  inp = c_win.pct_change().fillna(0).values
Â  Â  Â  Â  inp = torch.FloatTensor(inp).unsqueeze(0).to(device)
Â  Â  Â  Â  with torch.no_grad():Â 
Â  Â  Â  Â  Â  Â  s = self.m(inp)
Â  Â  Â  Â  Â  Â  scores = (s + self.h(s)).cpu().numpy()[0]
Â  Â  Â  Â  w = np.zeros(len(scores))
Â  Â  Â  Â  w[np.argsort(scores)[-3:]] = 1/3
Â  Â  Â  Â  return w

# =========================================================
# ğŸš€ ëª¬í…Œì¹´ë¥¼ë¡œ ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰
# =========================================================
def run_monte_carlo_benchmark():
Â  Â  print(f"ğŸš€ [Win QQQ] Monte Carlo Benchmark ({NUM_RUNS} Runs)")
Â  Â  print("Â  Â Fixed: Agent_JJH Scaling Issue")
Â  Â  print("â³ Loading Data...")
Â  Â Â 
Â  Â  close_df, vol_df = load_local_files()
Â  Â  if close_df is None:Â 
Â  Â  Â  Â  print("âŒ CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
Â  Â  Â  Â  return
Â  Â Â 
Â  Â  # QQQ ë°ì´í„°
Â  Â  qqq_path = '/content/QQQ.csv'
Â  Â  try:
Â  Â  Â  Â  if os.path.exists(qqq_path):
Â  Â  Â  Â  Â  Â  qqq_df = pd.read_csv(qqq_path)
Â  Â  Â  Â  Â  Â  if 'Date' in qqq_df.columns: qqq_df['Date'] = pd.to_datetime(qqq_df['Date'])
Â  Â  Â  Â  Â  Â  else: qqq_df.rename(columns={qqq_df.columns[0]: 'Date'}, inplace=True); qqq_df['Date'] = pd.to_datetime(qqq_df['Date'])
Â  Â  Â  Â  Â  Â  col_close = next((c for c in qqq_df.columns if 'close' in c.lower()), None)
Â  Â  Â  Â  Â  Â  if col_close:
Â  Â  Â  Â  Â  Â  Â  Â  qqq_data = qqq_df.set_index('Date')[col_close].astype(str).str.replace(r'[$,]', '', regex=True).astype(float)
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  qqq_data = pd.Series(0, index=close_df.index)
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  qqq_data = pd.Series(0, index=close_df.index)
Â  Â  except:
Â  Â  Â  Â  qqq_data = pd.Series(0, index=close_df.index)

Â  Â  # ë°ì´í„° ë¶„í• 
Â  Â  train_close = close_df.loc[:Config.TRAIN_END]
Â  Â  train_vol = vol_df.loc[:Config.TRAIN_END]
Â  Â Â 
Â  Â  test_close = close_df.loc[Config.TEST_START:]
Â  Â  test_vol = vol_df.loc[Config.TEST_START:]
Â  Â  test_dates = test_close.index
Â  Â Â 
Â  Â  avg_portfolio = {
Â  Â  Â  Â  'JJH': np.zeros(len(test_dates)),
Â  Â  Â  Â  'JHP(Quant)': np.zeros(len(test_dates)),
Â  Â  Â  Â  'IHK': np.zeros(len(test_dates)),
Â  Â  Â  Â  'HJK': np.zeros(len(test_dates)),
Â  Â  Â  Â  'YRK': np.zeros(len(test_dates)),
Â  Â  Â  Â  'QQQ': np.zeros(len(test_dates))
Â  Â  }
Â  Â  final_stats = {k: [] for k in avg_portfolio.keys()}Â 
Â  Â Â 
Â  Â  qqq_base = qqq_data.loc[test_dates[0]] if not qqq_data.empty and test_dates[0] in qqq_data.index else 1.0
Â  Â  if not qqq_data.empty and test_dates[0] in qqq_data.index:
Â  Â  Â  Â  qqq_curve = (qqq_data.loc[test_dates].fillna(method='ffill') / qqq_base) * Config.INITIAL_CAPITAL
Â  Â  else:
Â  Â  Â  Â  qqq_curve = pd.Series(Config.INITIAL_CAPITAL, index=test_dates)

Â  Â  print(f"\nğŸï¸ Running {NUM_RUNS} Simulations...")
Â  Â Â 
Â  Â  for seed in tqdm(range(1, NUM_RUNS + 1)):
Â  Â  Â  Â  set_all_seeds(seed)
Â  Â  Â  Â Â 
Â  Â  Â  Â  # 1. ëª¨ë¸ ì´ˆê¸°í™” & í•™ìŠµ
Â  Â  Â  Â  agents = {
Â  Â  Â  Â  Â  Â  'JJH': Agent_JJH(10),
Â  Â  Â  Â  Â  Â  'JHP(Quant)': Agent_JHP(10),
Â  Â  Â  Â  Â  Â  'IHK': Agent_IHK(10),
Â  Â  Â  Â  Â  Â  'HJK': Agent_HJK(10),
Â  Â  Â  Â  Â  Â  'YRK': Agent_YRK(10)
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  for agent in agents.values():
Â  Â  Â  Â  Â  Â  agent.train(train_close, train_vol)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  # 2. ë°±í…ŒìŠ¤íŠ¸
Â  Â  Â  Â  run_res = {name: [Config.INITIAL_CAPITAL] for name in agents.keys()}
Â  Â  Â  Â Â 
Â  Â  Â  Â  for i in range(len(test_dates)-1):
Â  Â  Â  Â  Â  Â  curr_date = test_dates[i]
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  c_win = close_df.loc[:curr_date].iloc[-60:]
Â  Â  Â  Â  Â  Â  v_win = vol_df.loc[:curr_date].iloc[-60:]
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  curr_prices = close_df.loc[curr_date]
Â  Â  Â  Â  Â  Â  next_prices = close_df.loc[test_dates[i+1]]
Â  Â  Â  Â  Â  Â  day_ret = (next_prices - curr_prices) / curr_prices
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  for name, agent in agents.items():
Â  Â  Â  Â  Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  w = agent.trade(c_win, v_win)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  port_ret = np.sum(day_ret * w)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new_val = run_res[name][-1] * (1 + port_ret)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  run_res[name].append(new_val)
Â  Â  Â  Â  Â  Â  Â  Â  except:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  run_res[name].append(run_res[name][-1])
Â  Â  Â  Â Â 
Â  Â  Â  Â  # 3. ëˆ„ì 
Â  Â  Â  Â  for name in agents.keys():
Â  Â  Â  Â  Â  Â  avg_portfolio[name] += np.array(run_res[name])
Â  Â  Â  Â  Â  Â  final_stats[name].append((run_res[name][-1] - Config.INITIAL_CAPITAL)/Config.INITIAL_CAPITAL*100)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  avg_portfolio['QQQ'] += qqq_curve.values
Â  Â  Â  Â  final_stats['QQQ'].append((qqq_curve.iloc[-1] - Config.INITIAL_CAPITAL)/Config.INITIAL_CAPITAL*100)

Â  Â  # ì‹œê°í™”
Â  Â  for name in avg_portfolio:
Â  Â  Â  Â  avg_portfolio[name] /= NUM_RUNS
Â  Â  Â  Â Â 
Â  Â  avg_df = pd.DataFrame(avg_portfolio, index=test_dates)
Â  Â Â 
Â  Â  plt.close('all')
Â  Â  plt.figure(figsize=(14, 7), dpi=120)
Â  Â Â 
Â  Â  colors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple', 'black']
Â  Â  for i, col in enumerate(avg_df.columns):
Â  Â  Â  Â  lw = 3 if col=='QQQ' else 2
Â  Â  Â  Â  ls = '--' if col=='QQQ' else '-'
Â  Â  Â  Â  plt.plot(avg_df.index, avg_df[col], label=col, linewidth=lw, linestyle=ls, color=colors[i%len(colors)], alpha=0.85)
Â  Â  Â  Â Â 
Â  Â  plt.title(f"Win QQQ Championship: Quantformer Edition ({NUM_RUNS} Runs) [Fixed]", fontsize=16)
Â  Â  plt.ylabel("Average Asset Value ($)")
Â  Â  plt.legend()
Â  Â  plt.grid(True, alpha=0.3)
Â  Â  plt.show()
Â  Â Â 
Â  Â  print("\nğŸ† [Monte Carlo Analysis] 100íšŒ ì‹¤í–‰ í‰ê·  ì„±ì  ğŸ†")
Â  Â  print("-" * 75)
Â  Â  print(f"{'Model':<20} | {'Avg Return':<12} | {'Best Run':<10} | {'Worst Run':<10} | {'Std Dev':<10}")
Â  Â  print("-" * 75)
Â  Â Â 
Â  Â  for name in avg_portfolio.keys():
Â  Â  Â  Â  rets = np.array(final_stats[name])
Â  Â  Â  Â  print(f"{name:<20} | {np.mean(rets):6.1f}%Â  Â  Â  | {np.max(rets):6.1f}%Â  Â  | {np.min(rets):6.1f}%Â  Â  Â | {np.std(rets):5.1f}")
Â  Â  print("-" * 75)

if __name__ == "__main__":
Â  Â  run_monte_carlo_benchmark()
